<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Self</title>
    <link href="/2025/09/01/Self/"/>
    <url>/2025/09/01/Self/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-zQwbBGVF" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="22802347" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"    ></div><p><font size=4><font face=STKaiti><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;八月过去了，夏天也快要过去了。我并没有把这几个月过成夏天的样子，没有体验新奇的事物，也没有好好感受周围的世界，只是凭着一口气苟延残喘。其实我好像让夏天提前出现了，属于Midwest Emo的四月，和朋友出门远行的五月和期待夏天的六月怎么看都比游戏、电视剧以及空调度过的七月、八月更像夏天。不是说游戏和电视剧不好，和它们度过的时间也很开心(《风骚律师》拍得真的很棒)，只是我印象中的夏天应该更热烈些，至少和以前度过的夏天有不同之处，而与游戏和电视剧度过的夏天我已经经历过了。这样看来，今年的确很没趣。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回想一下，以前的夏天，都做了一些什么呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18年以前：每个夏天具体干了什么已经记不起了，只是知道每一年应该都是和发小吃冰棍，骑车探险，去广场打球和躲猫猫。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18年夏：骑车，在同学家避雨，在他家玩了一整个下午的游戏，结交了最好的朋友。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19年夏：每晚熬夜冲浪，开始听英伦摇滚，听到了很多音乐，学会使用互联网。于是这个夏天慢慢开始形成了自己的审美。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20年夏：拥有了自己的第一部手机。和喜欢的女孩子表白失败，彻夜聊天。和发小决裂。注册了豆瓣。（糟糕，开始往伪文青的方向发展了）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21年夏：骑车听音乐，读书。趴床上读书落下了颈椎病。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22年夏：一整个夏天没有和很好的朋友聊天，听音乐看电影。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23年夏：和那个喜欢的女孩子重归于好，暧昧。在教室里翻小说，彻夜打电话。躺宿舍床上听walkman，看漫画。期待高考完的夏天。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24年夏：毕业旅行。初恋。报复性玩游戏。期待大学生活。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而这个夏天，除了帮家里干了一些活，就只是玩游戏，看电视剧，完全无视了暑假前制定的计划。甚至连音乐都没有好好听，头脑好像正在变得简单。好像我正在失去自己的<strong>self</strong>，可能这就是我最近心情莫名低落的原因。</p><p><br><center>「是我拒绝你已清醒的双眼，<br>是我召唤你眼底的错觉，<br>就让我用力砸碎轻声的诺言，<br>拥抱瞬间」</center><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绮贞的歌有一种沉静的力量，总能救我于水火之中。其实这个夏天，我只是做了歌词所描述的事。我曾经想过，其实每个人来到世界上，都是来修补残缺的自己的。而这个过程永远都不会停止，因为我们在修补的同时，也会有碎片掉落。“留下什么，我们就会变成什么样的大人。”好在，如果能够意识到，我们就能够控制这个过程。那怎么度过夏天就是怎么进行这个过程。这个夏天我失去了不少自己的<strong>self</strong>，希望我能慢慢找回来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;祝我们有许多不无聊的夏天。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>夏天</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何申请 GitHub Education 从而免费享受 Copilot Pro</title>
    <link href="/2025/08/20/%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7Github-Education%E5%85%8D%E8%B4%B9%E4%BA%AB%E5%8F%97Copilot-Pro/"/>
    <url>/2025/08/20/%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7Github-Education%E5%85%8D%E8%B4%B9%E4%BA%AB%E5%8F%97Copilot-Pro/</url>
    
    <content type="html"><![CDATA[<p><font face=STkaiti><font size=5>以下仅为个人经验分享，可能具有<strong>时效性</strong>和<strong>特殊性</strong>，旨在提高读者申请时的通过率，不保证一定能通过。如果文章有问题欢迎评论留言或者给我发邮件：<a href="mailto:&#101;&#108;&#x69;&#122;&#x61;&#98;&#x65;&#x74;&#104;&#x74;&#104;&#104;&#x68;&#64;&#103;&#109;&#97;&#x69;&#108;&#46;&#99;&#111;&#x6d;">elizabeththhh@gmail.com</a></font></p><h2 id="一、-GitHub-账号准备"><a href="#一、-GitHub-账号准备" class="headerlink" title="一、 GitHub 账号准备"></a>一、 GitHub 账号准备<font size=5></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;访问 GitHub 需要科学上网，具体方法请自行搜索</p><ol><li><p>如果你没有 GitHub 账号，请前往<a href="https://github.com/signup"> GitHub </a>注册一个账号。注册时使用教育邮箱（<code>edu.cn</code>后缀）</p></li><li><p>如果你已经有了GitHub账号，请确保你添加了并验证了教育邮箱<a href="https://github.com/settings/emails"> GitHub邮箱设置 </a></p></li></ol><p><img src="/img/cp/p1.jpg"></p><p>最后教育邮箱旁要出现<code>Verified</code>标签</p><ol start="3"><li><p><strong>账号信息设置</strong>（最关键的一步！）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;笔者因为账号设置的问题申请失败了二十次（特别鸣谢 GitHub 的优秀审核系统），折腾了好几个小时，包括但不限于拿着录取通知书对着电脑屏幕手舞足蹈，将自己的中文&#x2F;英文姓名各种排列组合填进账号信息……终于在即将崩溃的时候灵机一动成功了。</p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好的闲话少叙（咳咳）</p><ul><li>第一步，将自己的名字扔进<a href="https://www.bing.com/translator?setlang=zh-cn">微软翻译</a>（我猜是因为GitHub是微软家的，识别证明文件用的也是自家翻译。笔者最后福至心灵把名字换成了这个翻译才通过了）</li></ul><p> <img src="/img/cp/p2.png"></p><ul><li>第二步，将翻译的结果复制到<a href="https://github.com/settings/profile">GitHub个人档案</a>的 Name 栏下，然后在 Bio 一栏填入“xx University major in ……”， URL 填入学校的官方网址， Company 填入学校的官方英文名称， Location 填写学校地址即可</li></ul><p> <img src="/img/cp/p3.png"></p><ul><li>第三步，在<a href="https://github.com/settings/billing/payment_information"> Payment infomation </a>页面填写资料<br> <strong>注意</strong>：将刚才翻译好的名字，空格前的内容填入<strong>First Name</strong>，空格后的内容填进<strong>Last Name</strong>（不要管姓氏名字的语义问题，填就对了）。例如张小三翻译成<strong>Zhang</strong> <strong>Xiaosan</strong>，按图中的填就好。剩余内容如实填写即可。</li></ul><p> <img src="/img/cp/p4.png"></p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;最后，申请成功之后，上述信息都可以自行更改。不用担心实名上网。</p><ol start="4"><li><p>开启2FA认证</p><ol><li>前往<a href="https://github.com/settings/security">密码和验证</a>开启 2FA 认证</li></ol><p> <img src="/img/cp/p5.png"></p><ol start="2"><li>点击 <strong>Enable two-factor authentication</strong> 进入以下界面</li></ol><p> <img src="/img/cp/p6.png"></p><ol start="3"><li><p>微信小程序搜索 <strong>数盾OTP</strong>（或使用其它认证软件也可以）<br> 扫描界面中的二维码，输入验证码即可</p></li><li><p>输入验证码之后，会进入流程2</p></li></ol><p> <img src="/img/cp/p7.png"></p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击右下角 <strong>Download</strong> 把恢复码下载并保存好。（这个是当认证软件失效时的备用验证方式，一旦丢失将会无法验证，务必好好保存！）再点击 <strong>I have saved my recovery codes</strong>即可</p><ol start="5"><li>进入流程3，如果电脑有 Windows Hello 人脸识别或者指纹识别模块可以点击图中的 <strong>Add a passkey</strong> 方便以后登录</li></ol><p> <img src="/img/cp/p8.jpg"></p></li></ol><hr><p>账号设置完成🎉</p><p><font size=5><p class="note note-warning">注意：账号信息设置完成之后请在所有设备退出 GitHub 然后再重新登录，从而更新信息</p></font></p><h2 id="二、准备申请证明资料"><a href="#二、准备申请证明资料" class="headerlink" title="二、准备申请证明资料"></a></font>二、准备申请证明资料<font size=5></h2><p>GitHub提供的证明手段有：</p><ul><li>Dated school ID - Good （注明日期的学号 —— 证明效力强）</li><li>Dated official&#x2F;unofficial transcript （注明日期的成绩单 —— 证明效力一般）</li><li>Dated enrollment letter or school letter head （注明日期的录取通知书或学校信头 —— 证明效力一般）</li></ul><p>笔者自己试验过录取通知书，在学证明，成绩单。最后得出的结论是，为了提高通过率文件需要：</p><ol><li>有学校 Logo 和英文名称（如果只是书法体大学名可能无法被识别或准确翻译）</li><li><strong>包含自己的姓名和学号（学号可以提高通过率，没有学号的文件也可以试试），注有日期且没有被公章遮挡</strong></li><li>信息量少，简洁（为了让上面的信息更显眼更易于识别）</li></ol><p>笔者能找到的最符合上面条件的证明文件是学校开出的在学证明</p><p><img src="/img/cp/p9.jpg"></p><h2 id="三、申请教育优惠"><a href="#三、申请教育优惠" class="headerlink" title="三、申请教育优惠"></a></font>三、申请教育优惠<font size=5></h2><p class="note note-warning">注意：如果你的证明材料是电子版或电脑没有摄像头，请用手机登录 GitHub 完成下列操作（有拍照操作）。笔者这里推荐使用手机</p><p>前往<a href="https://github.com/settings/education/benefits">教育优惠申请</a>页面</p><p><img src="/img/cp/p10.jpg"></p><ol><li><p>点击 <strong>Start an application</strong> 开始认证</p><p> <img src="/img/cp/p11.jpg"></p><p> 如果没有列出你的学校，也请输入你的学校官方英文全称</p></li><li><p>位置分享</p><p> <img src="/img/cp/p12.jpg"></p> <p class="note note-warning">注意：点击 Share location 前请关闭科学上网**，分享完之后再开，然后点击 Continue</p></li><li><p>上传文件<br> <img src="/img/cp/p15.jpg"></p><p> 如果你找到的证明文件包括学号，请选择第一个 <strong>Dated scholl ID - Good</strong>， 否则如实选择</p><p> 点击 <strong>Start Camera</strong>， 拍摄你的证明文件，注意尽可能地让名字和日期显眼一些，也要把学校的 Logo 拍进去</p><p> 上传之后点击 <strong>Submit application</strong>即可，等待2-3分钟。如果成功会显示<strong>Approved</strong>，否则是<strong>Denied</strong>，同时失败的话 GitHub 会发邮件到你的教育邮箱，告知你失败的原因。根据失败原因调整，重新提交申请，多试几次。（笔者试了20次😅，不过读者按上述操作的话应该能很快成功）</p></li></ol><hr><p>Tips: 如果刚刚没有列出你的学校，会进入以下页面</p><p><img src="/img/cp/p13.jpg"></p><p>如实填写即可，填写完毕后点击 Continue</p><p>会进入以下界面：</p><p><img src="/img/cp/p14.png"></p><p>笔者没有进入过这个流程，不过建议准备多一些文件拼接在一起，点击 <strong>Upload a file</strong>，上传后点击 <strong>Submit Application</strong> 等待结果即可，不行就多试几次</p><hr><p>申请流程到这里就结束了，如果最后 <strong>Approved</strong> 了，三天内会收到 GitHub 的邮件</p><h2 id="四、激活Copilot"><a href="#四、激活Copilot" class="headerlink" title="四、激活Copilot"></a></font>四、激活Copilot<font size=5></h2><p>不出意外的话，你的教育邮箱会在三天后收到 GitHub 的邮件，提醒你的教育优惠已经到账。</p><p><img src="/img/cp/p17.jpg"></p><p>点击第一个链接，接下来会有两个问题，自行选择适合自己的即可</p><p><img src="/img/cp/p18.png"></p><p>回答完问题之后，GitHub会推荐一个合适的学习路径，不重要，直接点击 Continue to Dashboard 即可</p><p><img src="/img/cp/p19.png"></p><p>进入 Dashboard 之后，点击右上角 Learn more</p><p><img src="/img/cp/p20.png"></p><p>接着点击 Get access to GitHub Copilot</p><p><img src="/img/cp/p21.png"></p><p>接着自己选择偏好即可：</p><p><img src="/img/cp/p22.png"></p><p>选择好之后点击下一步就完成设置啦</p><h2 id="五、2FA-认证移除"><a href="#五、2FA-认证移除" class="headerlink" title="五、2FA 认证移除"></a></font>五、2FA 认证移除<font size=5></h2><p>拿到优惠之后就可以移除 2FA 认证了，因为这个真的很烦人。<br>前往<a href="https://github.com/settings/security">密保设置</a>，点击 2FA 认证右上角的三个点（如图）</p><p><img src="/img/cp/p16.jpg"></p><p>点击 Disable 即可</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Copilot</tag>
      
      <tag>GitHub Education</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A-week3</title>
    <link href="/2025/08/19/CS61A-week3/"/>
    <url>/2025/08/19/CS61A-week3/</url>
    
    <content type="html"><![CDATA[<p><font face=STkaiti><font size=5><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a></font>Python之禅<font size=5></h2><p><em><strong>Now is better than never.</strong></em></p><h2 id="语言知识"><a href="#语言知识" class="headerlink" title="语言知识"></a></font>语言知识<font size=5></h2><ol><li>可变数据与不可变数据<br>Python 中的数据分为可变与不可变，其中不可变数据类型指<strong>对象一旦创建，其内容（值）就不能被修改</strong>；可变数据类型指：<strong>对象的内容（值）在创建后可以被修改，而不会导致对象的内存地址发生变化</strong>。<ul><li>不可变数据类型（immutable）：<ol><li><code>int</code></li><li><code>string</code></li><li><code>tuple</code></li></ol></li><li>可变数据类型（mutable）：<ol><li><code>list</code></li><li><code>dict</code></li><li><code>set</code></li></ol></li></ul></li></ol><p>对于可变数据，对一个名称调用的方法可以同时影响另一个名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = a<br>a.append(<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><ol start="2"><li>比较运算符<br>Python 中有两个比较运算符<code>is</code>,<code>is not</code>，用来测试两个表达式是否求值为同一个对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>相同是比相等更强的条件</p><p>3.元组（tuple）<br>元组是内置类型，是不可变的序列。元组使用逗号分隔的元素表达式创建的元组字面量来创建。括号是可选的，但常用。任何对象都可以放在元组中。</p><p>空元组和单元素元组有特殊的字面量语法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>()    <span class="hljs-comment"># 0 elements</span><br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">10</span>,) <span class="hljs-comment"># 1 element</span><br>(<span class="hljs-number">10</span>,)<br></code></pre></td></tr></table></figure><ol start="3"><li>字典（dict）<br>字典是 Python 的内置数据类型，用于存储和操作对应关系。字典包含键值对，其中键和值都是对象。用花括号创建</li></ol><p>字典类型支持多种方法来整体迭代字典的内容。方法 <code>keys</code>、 <code>values</code> 和 <code>items</code> 都返回可迭代值  </p><p>字典也有类似于列表的推导式语法。键表达式和值表达式之间用冒号分隔。计算字典推导式会创建一个新的字典对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;x: x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)&#125;<br>&#123;<span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">5</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><p>字典的限制：</p><ul><li>字典的键不能是或包含可变值。</li><li>一个给定的键最多只能有一个值</li></ul><ol start="5"><li>LEGB Rule<br>Python 有四个作用域级别，分别是：  <ul><li>Local scope</li><li>Enclosing scope</li><li>Global scope</li><li>Built-in scope</li></ul></li></ol><p>当引用一个给定的名称时，如果它们都存在，Python 会按顺序在局部、封闭、全局和内置作用域级别中查找该名称。如果 Python 找到该名称，你将得到它的第一个或最内层的出现。否则，你将得到一个 NameError 异常。</p><p><img src="/img/w3/p1.png"></p><p>Python 提供了两个关键字，允许修改全局和非局部名字的内容：</p><ul><li>global</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>counter = <span class="hljs-number">0</span>  <span class="hljs-comment"># A global variable</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_counter</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">global</span> counter  <span class="hljs-comment"># Declares &#x27;counter&#x27; as a global variable</span><br><span class="hljs-meta">... </span>    counter = counter + <span class="hljs-number">1</span>  <span class="hljs-comment"># Successfully updates &#x27;counter&#x27;</span><br>...<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>update_counter()<br><span class="hljs-meta">&gt;&gt;&gt; </span>counter<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>update_counter()<br><span class="hljs-meta">&gt;&gt;&gt; </span>counter<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>update_counter()<br><span class="hljs-meta">&gt;&gt;&gt; </span>counter<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ul><li>nonlocal</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>():<br><span class="hljs-meta">... </span>    number = <span class="hljs-number">42</span>  <span class="hljs-comment"># A nonlocal variable</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nested</span>():<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">nonlocal</span> number  <span class="hljs-comment"># Declare &#x27;number&#x27; as nonlocal</span><br><span class="hljs-meta">... </span>        number += <span class="hljs-number">42</span><br><span class="hljs-meta">... </span>    nested()<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(number)<br>...<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>function()<br><span class="hljs-number">84</span><br></code></pre></td></tr></table></figure><p>更详细的介绍在<a href="https://realpython.com/python-scope-legb-rule/">LEGB Rule in Python</a></p><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a></font>编程思想<font size=5></h2><p>一、 抽象（abstraction）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 数据抽象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将程序中处理数据表示和数据操作的部分分离开的方法，叫作<em><strong>数据抽象</strong></em>（data abstraction）<br>数据抽象和函数抽象很相似。在实现函数抽象时，我们可以将函数的使用方式与其实现细节分离，程序员值需要考虑传入的数据和返回数据之间的关系即可。用乘车来类比，只需要买一张从X地到Y地的票即可实现目的，不需要关注客运网络的实现方式。类似的，数据抽象是将数据的用法和构造细节分离。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 抽象屏障（abstraction barriers）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以有理数为例，用列表来实现有理数，并定义了一系列函数：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. <code>add_rational</code> <code>mul_rational</code>等。这些函数有较高的抽象层次调用，以较低的抽象层次实现。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. <code>make_rational()</code>传入numerator和denominator用来构造一个有理数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要计算两个有理数的乘积，却使用了较低抽象层次的函数就会发生<strong>abstraction barrier violation</strong>。为了避免这种情况应该调用<code>add_rational</code>，即较高层次的调用不应该考虑任何有理数的实现细节</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square_rational</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> mul_rational(x, x)<br></code></pre></td></tr></table></figure><p>直接引用分子和分母将违反一个抽象层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square_rational_violating_once</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> rational(numer(x) * numer(x), denom(x) * denom(x))<br></code></pre></td></tr></table></figure><p>假设有理数表示为两元素列表将违反两个抽象屏障。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">square_rational</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> mul_rational(x, x)<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>抽象屏障使程序更易与维护和修改</strong>。依赖于特定实现方式的函数越少，当需要改变时某些细节时所导致的变化就会越少。以上函数中只有最后一个对未来的变化具有鲁棒性——即使改变有理数的实现方式也不需要更新函数</p><p>二、 对象（object）</p><p><strong>为数据添加状态是面向对象编程范式的一个核心要素</strong>。对象结合了数据和行为。对象既是信息也是过程，捆绑在一起以表示复杂事物的属性、交互和行为。</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a></font>作业<font size=5></h2><p>完成了 hw03，lab03 和 cats</p><p>在完成作业的时候学习了两个在搜索算法中很重要的实现：</p><ol><li>剪枝 —— 通过某种判断，减少搜索过程中不必要的遍历</li><li>记忆化搜索 —— 通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式</li></ol><p>cats 这个项目中的 <code>final_diff()</code> 很好的体现了这两点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">final_diff</span>(<span class="hljs-params">typed, source, limit</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;A diff function that takes in a string TYPED, a string SOURCE, and a number LIMIT.</span><br><span class="hljs-string">    If you implement this function, it will be used.&quot;&quot;&quot;</span><br>    <br><span class="hljs-comment"># 记忆化搜索</span><br>    <span class="hljs-comment"># 在递归过程中使用字典存储，键：某一参数状态 值：这一参数状态对应的结果</span><br><span class="hljs-comment"># 可以有效避免递归过程中的重复计算，提高性能</span><br>    memo = &#123;&#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">typed, source, limit</span>):<br>        <br>        key = (typed, source, limit)  <span class="hljs-comment"># 当前递归的参数状态</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> memo:<br>            <span class="hljs-keyword">return</span> memo[key]<br>       <br>   <span class="hljs-comment"># 剪枝，当limit小于0时，就没有必要再进行下去了，剪掉这个枝条</span><br>        <span class="hljs-keyword">if</span> limit &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> limit + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> typed == source:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(typed) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(source)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(source) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(typed)<br>            <br>        <span class="hljs-keyword">if</span> typed <span class="hljs-keyword">in</span> common_typos.get(source, []):<br>            memo[key] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 更新记忆</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">if</span> typed[<span class="hljs-number">0</span>] == source[<span class="hljs-number">0</span>]:<br>            result = helper(typed[<span class="hljs-number">1</span>:], source[<span class="hljs-number">1</span>:], limit)<br>            memo[key] = result  <span class="hljs-comment"># 更新记忆</span><br>            <span class="hljs-keyword">return</span> result<br>        <br>        operations = []<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(typed) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(source) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <br>            typed[<span class="hljs-number">0</span>] == source[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> typed[<span class="hljs-number">1</span>] == source[<span class="hljs-number">0</span>]):<br>            operations.append(<span class="hljs-number">1</span> + helper(typed[<span class="hljs-number">2</span>:], source[<span class="hljs-number">2</span>:], limit - <span class="hljs-number">1</span>))<br>        <br>        <span class="hljs-keyword">if</span> typed[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> adja_typos.get(source[<span class="hljs-number">0</span>], []):<br>            typo_cost = <span class="hljs-number">0.3</span><br>            operations.append(typo_cost + helper(typed[<span class="hljs-number">1</span>:], source[<span class="hljs-number">1</span>:], limit - typo_cost))<br>        <span class="hljs-keyword">elif</span> source[<span class="hljs-number">0</span>].lower() <span class="hljs-keyword">in</span> adja_typos.get(typed[<span class="hljs-number">0</span>].lower(), []):<br>            typo_cost = <span class="hljs-number">0.3</span><br>            operations.append(typo_cost + helper(typed[<span class="hljs-number">1</span>:], source[<span class="hljs-number">1</span>:], limit - typo_cost))<br>        <br><br>        operations.extend([<br>            <span class="hljs-number">1</span> + helper(typed, source[<span class="hljs-number">1</span>:], limit - <span class="hljs-number">1</span>),     <br>            <span class="hljs-number">1</span> + helper(typed[<span class="hljs-number">1</span>:], source, limit - <span class="hljs-number">1</span>),     <br>            <span class="hljs-number">1</span> + helper(typed[<span class="hljs-number">1</span>:], source[<span class="hljs-number">1</span>:], limit - <span class="hljs-number">1</span>)  <br>        ])<br>        <br>        result = <span class="hljs-built_in">min</span>(operations)<br>        memo[key] = result  <span class="hljs-comment"># 更新记忆</span><br>        <span class="hljs-keyword">return</span> result<br>    <br>    <span class="hljs-keyword">return</span> helper(typed, source, limit)<br><br></code></pre></td></tr></table></figure><p><a href="https://github.com/Elizabeththh/cs61a">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Python_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python学习</tag>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A-week2</title>
    <link href="/2025/08/17/CS61A-week2/"/>
    <url>/2025/08/17/CS61A-week2/</url>
    
    <content type="html"><![CDATA[<p><font face=STkaiti><font size=4><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习了第一周的内容。体会到为什么大家都说61a难了，第一周就讲了高阶函数，作业有HW01, Lab00和Hog。虽然我已经有了c和cpp的使用经验，但是在完成作业的过程中也遇到了不少的困难（尤其是hog项目）。与此同时，我也越来越能体会到使用python能带来的便利和简洁，在cpp中要四五行代码才能实现的功能，python一条推导式就能解决。所以希望我能把这门优雅的编程语言学好吧。</p><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a></font>Python之禅<font size=5></h2><p><em><strong>If the implementation is hard to explain, it’s a bad idea.</strong></em></p><h2 id="语言知识"><a href="#语言知识" class="headerlink" title="语言知识"></a></font>语言知识<font size=5></h2><p>这一周没有什么新的语法知识，更多的是和数据结构与递归有关的编程思想</p><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a></font>编程思想<font size=5></h2><ol><li>递归<br>递归的本质是将复杂问题分解成更小的子问题求解的过程，关键在于：<br>1. 明确终止条件（base case）<ol start="2"><li>如何利用<strong>自相似</strong>缩小问题规模（写出递归语句）</li></ol></li></ol><p>理论上，所有递归都能用迭代（循环）来完成，但是递归能帮助我们更好地理解问题求解过程，一般也更加简洁。但是在利用递归的时候需要注意<em>stack overflow</em>的可能。（比如斐波那契问题用递归解决会重复求解非常多的相同子问题，造成巨大的资源浪费）</p><ol start="2"><li>递归写法的选择<br><img src="/img/w2/p1.png"></li></ol><p>图片中左右两个函数的递归是等价的。但是左边的写法更易读。程序员所写的程序，是给别人看的（当然也包括自己）。如果能以更简洁易读的方式设计程序，可以让程序更易于维护，<strong>so please do ourselves a favor</strong>。</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a></font>作业<font size=5></h2><p>完成了hw02, lab02<br><a href="https://github.com/Elizabeththh/cs61a">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Python_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python学习</tag>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A_week1</title>
    <link href="/2025/08/16/CS61A-week1/"/>
    <url>/2025/08/16/CS61A-week1/</url>
    
    <content type="html"><![CDATA[<p><font face=STkaiti><font size=4><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开始第一周的学习！在未来的日志里，我会将关注点放所学习到的编程思想上，而不是零零碎碎的语法知识。（当然也会记录一下Python核心&#x2F;陌生概念，尽量简洁）编程语言有许多，语法也存在大大小小的差别。但是编程思想，或者说解决问题的哲学是通用的。学习计算机就是学习如何用编程思想解决问题。</p><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a></font>Python之禅<font size=5></h2><p><em><strong>There should be one– and preferably only one –obvious way to do it.</strong></em></p><h2 id="语言知识"><a href="#语言知识" class="headerlink" title="语言知识"></a></font>语言知识<font size=5></h2><ol><li>在Python中赋值语句是将<strong>名字</strong>绑定到<strong>值</strong>的过程</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>radius = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>radius<br><span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> * radius<br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><code>radius</code>被绑定到了值<code>10</code></p><p>这种绑定还可以通过<code>import</code>语句来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi<br><span class="hljs-meta">&gt;&gt;&gt; </span>pi * <span class="hljs-number">71</span> / <span class="hljs-number">223</span><br><span class="hljs-number">1.0002380197528042</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>解释器用来追踪<strong>名字</strong>、<strong>值</strong>与它们之间的<strong>绑定</strong>的内存就是<strong>环境</strong></p></li><li><p>函数有两种：调用时会产生副作用的和不会的，分别对应<strong>Non-pure</strong>和<strong>Pure</strong></p></li></ol><p>下面两幅图就能很形象地描述这种不同：<br><img src="/img/w1/p1.png"><br><img src="/img/w1/p2.png"></p><ol start="4"><li><p>环境是一系列的栈帧<br>查找一个<strong>名字</strong>，会先在当前栈帧查找，如果没有找到，则依次到parent frames查找直到global frames</p></li><li><p>断言语句：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> fib(<span class="hljs-number">8</span>) == <span class="hljs-number">13</span>, <span class="hljs-string">&#x27;The 8th Fibonacci number should be 13&#x27;</span><br></code></pre></td></tr></table></figure><p>语法：断言关键字 表达式, 字符串<br>当表达式求值为<code>False</code>时，<code>assert</code>会cause an AssertionError，并将所给字符串显示。反之没有效果。</p><ol start="6"><li>Doctests<br>python允许在Docstring里放置简单的测试，导入对应库即可</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return the sum of the first n natural numbers.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        &gt;&gt;&gt; sum_naturals(10)</span><br><span class="hljs-string">        55</span><br><span class="hljs-string">        &gt;&gt;&gt; sum_naturals(100)</span><br><span class="hljs-string">        5050</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> k &lt;= n:<br>            total, k = total + k, k + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> doctest <span class="hljs-keyword">import</span> testmod<br><span class="hljs-meta">&gt;&gt;&gt; </span>testmod()<br>TestResults(failed=<span class="hljs-number">0</span>, attempted=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>或者写一个独立的函数来运行测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> doctest <span class="hljs-keyword">import</span> run_docstring_examples<br><span class="hljs-meta">&gt;&gt;&gt; </span>run_docstring_examples(sum_naturals, <span class="hljs-built_in">globals</span>(), <span class="hljs-literal">True</span>)<br>Finding tests <span class="hljs-keyword">in</span> NoName<br>Trying:<br>    sum_naturals(<span class="hljs-number">10</span>)<br>Expecting:<br>    <span class="hljs-number">55</span><br>ok<br>Trying:<br>    sum_naturals(<span class="hljs-number">100</span>)<br>Expecting:<br>    <span class="hljs-number">5050</span><br>ok<br></code></pre></td></tr></table></figure><p>第一个参数是函数名；第二个是内置函数<code>globals()</code>，返回全局环境；最后一个是是否开启<em>verbose output</em>的布尔值  </p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a></font>高阶函数<font size=5></h3><p>高阶函数是指能够接收一个或多个函数作为参数，或者返回一个函数作为结果的函数。</p><ol start="7"><li>函数的柯里化(Currying)<br>把接受多个参数的函数变换成接受<strong>单一参数</strong>的函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">curried_pow</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x, y)<br>        <span class="hljs-keyword">return</span> h <br><span class="hljs-meta">&gt;&gt;&gt; </span>curried_pow(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>可以定义一个可以将其它函数（去）柯里化的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">curry2</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return a curried version of the given two-argument function.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>                <span class="hljs-keyword">return</span> f(x, y)<br>            <span class="hljs-keyword">return</span> h<br>        <span class="hljs-keyword">return</span> g<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">uncurry2</span>(<span class="hljs-params">g</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return a two-argument version of the given curried function.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x, y</span>):<br>            <span class="hljs-keyword">return</span> g(x)(y)<br>        <span class="hljs-keyword">return</span> f<br></code></pre></td></tr></table></figure><p>以上利用了函数可以作为返回值的特性</p><ol start="8"><li>Lambda Expressions(匿名函数)<br>Lambda表达式的值是一个只有一条返回语句的函数，赋值和控制语句不允许在函数体内出现</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">compose1</span>(<span class="hljs-params">f, g</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x: f(g(x))<br></code></pre></td></tr></table></figure><table><thead><tr><th>lambda</th><th>x</th><th>:</th><th>f(g(x))</th></tr></thead><tbody><tr><td>A function that</td><td>takes x</td><td>and returns</td><td>f(g(x))</td></tr></tbody></table><ol start="9"><li><p>First-Class Functions（一等函数）<br>一等函数指在程序设计语言中，函数被当作一等对象。意味着函数可以</p><ol><li>作为其他函数的参数</li><li>作为函数的返回值</li><li>绑定&#x2F;赋值给变量</li><li>存储在数据结构中<br>在Python中，函数是一等对象</li></ol></li><li><p>Decorators（装饰器）</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; &#x27;</span>, fn, <span class="hljs-string">&#x27;(&#x27;</span>, x, <span class="hljs-string">&#x27;)&#x27;</span>)<br>            <span class="hljs-keyword">return</span> fn(x)<br>        <span class="hljs-keyword">return</span> wrapped<br><span class="hljs-meta">&gt;&gt;&gt; </span>@trace<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>triple(<span class="hljs-number">12</span>)<br>-&gt;  &lt;function triple at <span class="hljs-number">0x102a39848</span>&gt; ( <span class="hljs-number">12</span> )<br><span class="hljs-number">36</span><br></code></pre></td></tr></table></figure><p>实际上是做了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>triple = trace(triple)<br></code></pre></td></tr></table></figure><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a></font>编程思想<font size=5></h2><ol><li><p>绑定是最简单的抽象(abstraction)<br>这种将数值抽象为有具体意义的概念的做法，可以让我们在思考问题时不必关心数据的多少，变化，从而简化思维过程。当然程序员要确保并维护<strong>名字</strong>与相对应的<strong>数值</strong>绑定</p></li><li><p>定义函数的哲学</p><ul><li>每个函数应该负责一个具体的功能</li><li><em><strong>DRY</strong></em>原则：Don’t repeat yourselves</li><li>函数的功能应泛化——提高可复用性（例如定义<code>pow()</code>而不是只定义<code>square()</code>）</li></ul></li><li><p>及时对函数进行测试<br>有效测试的关键是对在实现了一个新函数之后马上对其进行测试，甚至是在实现函数之前就写好一些测试数据。<br>对一个函数的测试叫作单元测试（unit testing），良好的设计需要的单元测试。</p></li><li><p>抽象<br>作为程序员，我们要有能够识别我们的程序中底层抽象的能力，并对其进行泛化以构建更强大的抽象。作为程序员，我们要选择适合任务的抽象级别。厕所脏了，在清理的时候把脏东西抽象碳氮等元素的有机组成显然是不合适的。解决具体的问题应该在具体、合适的抽象级别思考。</p></li></ol><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a></font>作业<font size=5></h2><p>HW01, Lab00和hog都已完成，已经推送到github仓库：<br><a href="https://github.com/Elizabeththh/cs61a">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Python_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python学习</tag>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A_介绍</title>
    <link href="/2025/08/15/CS61A-intro/"/>
    <url>/2025/08/15/CS61A-intro/</url>
    
    <content type="html"><![CDATA[<h1 id="CS61A学习记录"><a href="#CS61A学习记录" class="headerlink" title="CS61A学习记录"></a><font face=STKaiti><center>CS61A学习记录</center><font size=5></h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;久仰这门课的大名了，但是因为太懒一直没有开始学。Python之前一直是东学一些，西学一些。最近因为工作的需要打算系统地学习一下Python，于是决定从今天开始学习。选择的是最新的2025 Summer课程（但其实都一样，视频和教程都是古早的），预计暑假结束前完成。</p><p>这里贴一些课程相关的链接：<br><a href="https://cs61a.org/">课程网站</a><br><a href="https://www.composingprograms.com/">课程教材</a></p>]]></content>
    
    
    <categories>
      
      <category>Python_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python学习</tag>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
